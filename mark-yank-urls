#!/usr/bin/perl
# Author:  Bart Trojanowski <bart@jukie.net>
# Website: http://www.jukie.net/~bart/blog/urxvt-url-yank
# License: GPLv2

use strict;
use warnings;

use DBI;
use Data::Dumper;

my $url_matcher = qr{(
        (?:https?://|ftp://|news://|mailto:|file://|www\.)[ab-zA-Z0-9\-\@;\/?:&=%\$_.+!*\x27(),~#]+
        [ab-zA-Z0-9\-\@;\/?&=%\$_+!*\x27()~]   # exclude some trailing characters (heuristic)
)}x;

my %keymap = (
    Escape  => 'cancel',
    Return  => 'open',
    y       => 'yank',
    n       => 'next',
    p       => 'prev',
);
my $mark_mode_active = 0;
my $url_selected = -1;
my %mod = ( 'control' => 0, 'shift' => 0 );
my $dbh = DBI->connect("dbi:SQLite:dbname=$ENV{HOME}/.urxvt/urls.sqlite", { RaiseError => 1 }) or die "Can't open URL database";
my $insert_url_query = $dbh->prepare('INSERT INTO urls VALUES (?);') or die "Can't prepare insert query";
my $is_visited_url_query = $dbh->prepare('SELECT COUNT(*) FROM urls WHERE url = ?;') or die "Can't prepare select query";
my $overlay;
my @urldb;

sub move_selection {
    my ($term, $dir) = @_;

    set_selection($term, $url_selected, 0);
    $url_selected = ($url_selected + $dir) % ($#urldb + 1);
    set_selection($term, $url_selected, 1);

    $term->want_refresh;
}

sub set_selection {
    my ($term, $index, $enable) = @_;
    my $url = $urldb[$index];

    for (my $i = 0; $i < scalar @{$url->{rend}}; $i++) {
        my $x = @{$url->{rend}}[$i];
        $x &= ~urxvt::RS_RVid;
        $x |= urxvt::RS_RVid if $enable;

        $x = urxvt::SET_BGCOLOR($x, 6) if (is_visited($url->{url}));
        @{$url->{rend}}[$i] = $x;
    }
    $overlay->set($url->{col}, $url->{row}, $url->{url}, $url->{rend});
}

sub setup_overlay {
    my ($term) = @_;

    $overlay = $term->overlay(0, 0, $term->ncol, $term->nrow, 0, 0);

    for my $rowno (0 .. ($term->nrow - 1)) {
        my $line = $term->ROW_t($rowno);
        my $rend = $term->ROW_r($rowno);
        $overlay->set(0, $rowno, $line, $rend);

        while ($line =~ /($url_matcher)/g) {
			my ($url, $first, $last) = ($1, $-[1], $+[1] - 1);
			--$last if $url =~ s/["']$//;

            my %tuple = (
				row => $rowno,
				col => $first,
				last => $last,
				url => $url,
                rend => [ @$rend[$first .. $last] ],
			);
            push @urldb, \%tuple;
        }

    }
    return scalar @urldb;
}

sub on_start {
    my ($term) = @_;

    $term->{have_Clipboard} = eval { require Clipboard; };
    if ($term->{have_Clipboard}) {
        import Clipboard;
    }

	eval { require Regexp::Common::URI };
	if(!$@) {
		require Regexp::Common;
		Regexp::Common->import('URI');

		$url_matcher = $Regexp::Common::RE{URI}{HTTP};
	}

    $term->{browser} = $term->x_resource ("urlLauncher") || "x-www-browser";

    ()
}

sub on_button_release {
    my ($term, $event) = @_;

    my $mask = $term->ModLevel3Mask | $term->ModMetaMask
    | urxvt::ShiftMask | urxvt::ControlMask;

    if ($event->{button} == 2 && ($event->{state} & $mask) == 0) {
        my $row = $event->{row};
        my $col = $event->{col};

        my $line = $term->line ($row);
        my $text = $line->t;

        while ($text =~ /($url_matcher)/g) {
            my ($url, $first, $last) = ($1, $-[1], $+[1]);

            if($first <= $col && $last >= $col) {
                $url =~ s/["']$//;
                $term->exec_async($term->{browser}, $url);
                return 1;
            }
        }
    }

    ()
}



sub set_visited {
    my ($url) = @_;
    $insert_url_query->execute($url) unless is_visited($url);
}

sub is_visited {
    my ($url) = @_;
    $is_visited_url_query->execute($url);
    my @result = $is_visited_url_query->fetchrow_array();
    return $result[0];
}

sub on_line_update {
    my ($term, $row) = @_;

    # Fetch the line that has changed.
    my $line = $term->line($row);
    my $text = $line->t;

    # Find and underline URLs.
    while ($text =~ /($url_matcher)/g) {
        my $url = $1;
        my $rend = $line->r;

        # Mark all characters as underlined. we _must_ not toggle underline, as
        # we might get called on an already-marked URL.
        my $underlineURLs = $term->x_resource ('underlineURLs') || 'false';
        if($underlineURLs eq 'true') {
			my ($first, $last) = ($-[1], $+[1] - 1);

			--$last if $url =~ s/["']$//;

            for (@{$rend}[$first .. $last]) {
                $_ |= urxvt::RS_Uline;
                if (is_visited($url)) {
                    $_ = urxvt::SET_BGCOLOR($_, 6);
                }
            }

            $line->r($rend);
        }
    }

    ()
}


sub on_user_command {
    my ($term, $cmd) = @_;

	activate_mark_mode($term) if $cmd eq 'mark-yank-urls:activate_mark_mode';

    ()
}

sub on_key_press {
    my ($term, $event, $keysym, $octets) = @_;

    if ($keysym == 65507) {                     # <control>
        $mod{control} = 1;

    } elsif ($keysym == 65505) {                # <shift>
        $mod{shift} = 1;

    }

    # Ignore all input when we are active.
    $mark_mode_active && return 1;

    ()
}

sub on_key_release {
    my ($term, $event, $keysym, $octets) = @_;


    if ($mark_mode_active) {
        my $keystr = $term->XKeysymToString($keysym);
        my $evt = $keymap{$keystr} || 0;

        if ($evt eq 'cancel') {
            deactivate_mark_mode ($term);
            return 1;

        } elsif ($evt eq 'open') {
            my $url = get_active_url($term);
            $term->exec_async($term->{browser}, $url);
            set_visited($url);
            deactivate_mark_mode ($term);
            return 1;

        } elsif ($keysym == 65507) {                # <control>
            $mod{control} = 0;
            return 1;

        } elsif ($keysym == 65505) {                # <shift>
            $mod{shift} = 0;
            return 1;

        } elsif ($mod{control} && ($evt eq 'next' || $evt eq 'prev')) {
            my $dir = ($evt eq 'next') ? 1 : -1;
            move_selection($term, $dir);
        } elsif ($evt eq 'yank') {
            my $url = get_active_url($term);
            set_visited($url);
            do_copy ($term);
            deactivate_mark_mode ($term);
            return 1;

        }

        return 1;
    }

    ()
}

sub get_active_url {
    my ($term) = @_;

    return $urldb[$url_selected]->{url};
}

sub do_copy {
    my ($term) = @_;

    my $text = get_active_url ($term);

    if ($term->{have_Clipboard}) {
        Clipboard->copy($text);
    } else {
        $text =~ s/\(["|><&()]\)/\\$1/;
        system ("echo -n \"$text\" | xclip -i");
    }
}

sub activate_mark_mode {
    my ($term) = @_;

    if ($mark_mode_active) {
        move_selection($term, -1);

    } elsif (setup_overlay($term)) {
        $overlay->show();
        $url_selected = $#urldb;
        set_selection($term, $url_selected, 1);
        $mark_mode_active = 1;
    } else {
        $overlay->hide();
    }
}

sub deactivate_mark_mode {
    my ($term) = @_;

    $mark_mode_active = 0;
    @urldb = ();
    $overlay->hide();
    $term->want_refresh;
}

# vim: set et ts=4 sw=4:
